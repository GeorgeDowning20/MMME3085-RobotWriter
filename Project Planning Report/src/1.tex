The program's aim is to print out text on a robot arm by sending G-code instructions over a serial interface. It uses a font file that defines code for different ASCII characters. The program must ask the user for a text file to print and the height of the text to print.

The project will be developed for a cross-platform experience using Windows (MSYS2), Linux, and Mac. GitHub will be used for version control. Automated workflows on Git Hub will compile and run the code to ensure compatibility across platforms. Documentation will be generated via doxygen in an automated workflow on Git Hub in the gh-pages branch, which will then be published on a static website. The program will be compiled using the GCC compiler, which makes it easy to compile on all platforms. 

The first aspect of the project will include parsing the font file. The program will use a structure to hold the code instructions. Ideally, this should use dynamic memory allocation to allow for different and more complex fonts with variable strokes/letters. The file will use the fopen() function from stdio.h to open the file. A loop will iterate through all file lines using the fgets() function. When 999 is found, indicating a new character, the program will allocate memory for the new character and the strokes that follow. All characters dynamically allocated will be mapped with a hash table, with the ASCII value of the character as the key.

An interesting problem is selecting the G-code Information given the ASCII character. A simple approach would be to iterate through the array and find the matching ASCII character. This, however, would have a slow time complexity of O(n). A better approach might be to sort the array so the index of the code array is the same as the ASCII value. This would have a time complexity of O(1). However, this requires either sorting the font file or implementing a sorting algorithm. Alternatively, a hash table could be used with an O(1) time complexity. This would allow nonsorted font files to be used efficiently and is easily extendable for other ASCII standards, including Unicode. 

The project's next stage will require the scaling of the code instructions; a simple command line dialog using printf() and scanf() will allow the user to input the font size they want. The program will then iterate through characters and font strokes and scale the x and y strokes. The scale is defined by double scale = (double)/ 18.0f; 

Next, the stage will be to input the test.txt file. A simple command line dialog using printf() and scanf() will allow users to input the file they want to print out. The file can be opened with fgets(). The specification requires that each word is read from the file individually and processed before reading the next one. While fscanf() could be used to read each individual word, it misses out on the ability to process punctuation or special characters such as a space or $\backslash$n. Therefore, the best way of processing will be to use fgetc() to read each character individually, appending it to a buffer. When a special character is found, the buffer is copied to an array, which can be processed. 

As each word is pulled from the text file, the program will call a function to assemble the code to send to the robot. Static variables will be utilized to keep track of the cursor position. The function will iterate through the word (array of characters), where it will first look for special characters, such as $\backslash$n, to update the cursor position(garage return with 5mm line spacing ). The ASCII value of the character will be used as the key in a hash function to return a pointer to the code instructions for the character. The function will then iterate through the stokes of the character, sending the code to the robot with the appropriate G0 or G1 command for the pen up or down position. Next, the cursor position will be updated to leave a small space between letters. Before sending a new G-code instruction, the program will wait for the OK$\backslash$n response from the robot to confirm it has room in the buffer for the next instruction. The robot will be communicated via a serial port using the RS232 library provided.
